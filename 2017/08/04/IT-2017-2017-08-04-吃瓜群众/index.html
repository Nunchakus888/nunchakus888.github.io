<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="keywords" content="Javascript,Nunchakus,Tricking,Kufu,Roidder"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><title>AV大战之～吃瓜群众</title><meta name="keywords" content="JS"><body><div style="visibility: hidden; width: 0; height: 0"><img src="https://nunchakus888.github.io/images/share-logo.jpg"></div><div class="container"><div class="nav"><ul><li class="item"><a href="/">🙄️</a></li><li class="item"><a href="/archives">一篇诗</a></li><li class="item"><a href="/category">一壶酒</a></li><li class="item"><a href="/tags/">一曲长歌</a></li><li class="item"><a href="/about/">一剑天涯</a></li></ul></div><article><header><h1 class="title">AV大战之～吃瓜群众</h1><i class="icon-calendar"></i><span>2017.08.04 | 01:08:08</span></header><div class="content"><hr>
<p>中国大地的各大开发者社区统统被Angular&amp;Vue的撕逼大战刷屏-几近波及世界😄-那些大佬真是着急了什么话都能说得出来啊-干货满满的-我默默点赞-默默吃瓜-默默做笔记િ🙄ી&amp;致敬大佬们</p>
<h3 id="AngularJs双向数据绑定"><a href="#AngularJs双向数据绑定" class="headerlink" title="AngularJs双向数据绑定"></a>AngularJs双向数据绑定</h3><blockquote>
<p>AngularJS 1.x会为每一个进行数据绑定的HTML标签创建一个watcher。然后，当发生任何可能会导致数据模型被修改的情况下，就会启动一轮$digest循环，把所有watcher全部运行一遍，看看有没有东西需要自己更新（目前Vue的实现思想与此类似，它底层使用了Object.defineProperty）。AngularJS 1.x在这个地方还有一个实现细节也非常糟糕，它为了保证数据模型的改动不会丢失，可能会重复运行多次$digest循环，而且搞了一个TTL机制，如果$digest循环检查了10次，发现模型还没有稳定下来，直接抛异常。<br>    -脏值检测的效率问题：在AngularJS 1.x里面，这个问题没有得到很好的解决。它每次都会生成一份对象副本，当发生修改之后，会把新的对象和原来的对象进行“深比较”。当JS对象的结构非常深的时候，Tree型遍历会消耗大量的CPU时间，因为Tree型遍历一般需要递归，而在JS里面做递归运行效率非常差。同时因为每次都拷贝一个对象副本，内存占用也比较大，这就是你们在网上看到很多吐槽说AngularJS 1.x的数据绑定有效率问题的根本原因。</p>
</blockquote>
<h3 id="Angular2-双向数据绑定"><a href="#Angular2-双向数据绑定" class="headerlink" title="Angular2+ 双向数据绑定"></a>Angular2+ 双向数据绑定</h3><blockquote>
<p>如何才能检测到某个JS对象的值被修改了：新版本的Angular引入了Zones.js，并在此基础上做了自己的封装，Zones会拦截所有可能修改数据模型的操作。实际上在浏览器环境下，只有3个典型的异步回调才可能造成数据模型被修改：事件回调、Ajax回调、定时器回调。所以，Zones.js拦截了所有这些回调函数，自己做了代理。这样，它就可以在数据发生修改的时候精确地给Angular发出通知，因此，在Angular新版本里面，不会再出现更新丢失的问题，你再也不用自己去手动调用该死的$apply()方法了。</p>
<pre><code>- 脏值检测的效率问题：新版本的Angular引入了RxJS+Immutable的设计，非常有效地避开了这个问题。根据Victor Savkin的说法，这个全新的实现把运行效率从O(N)提升到了O(logN)。所以，在新版本的Angular里面，不再存在所谓的“绑定效率”问题了，有一些无脑黑的文章还在扯这个问题，明显是胡说。
</code></pre></blockquote>
<h3 id="AOT-amp-JIT"><a href="#AOT-amp-JIT" class="headerlink" title="AOT&amp;JIT"></a>AOT&amp;JIT</h3><blockquote>
<p>AOT(Ahead Of Time，预编译)是和JIT(Just In Time，即时编译)相对应的一个概念，<br>    虽然JavaScript代码是解释执行的，<br>    但是浏览器在执行JS代码的时候同样需要编译，<br>    这种<code>一边编译一遍执行的方式叫做JIT</code>。<br>    JIT存在一些问题，首先是 <code>效率不够高，其次是没法做深度的代码优化</code>。<br>    tree-shaking的意思是“摇树”，这是一个非常生动形象的比喻，当你摇一颗树的时候，那些枯萎的叶子就会掉下来。而我们在编写应用的过程，经常会有一些代码可能根本用不到，<br>    有了tree-shaking之后，这些用不到的东西就可以自动被摇掉，<br>    从而可以保证最终打包出来的应用体积足够小。<br>    如果没有静态类型的TypeScript，要实现tree-shaking也会非常麻烦。</p>
</blockquote>
</div></article><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = "https://nunchakus888.github.io/2017/08/04/IT-2017-2017-08-04-吃瓜群众/";
  this.page.identifier = "2017/08/04/IT-2017-2017-08-04-吃瓜群众/";
};

(function () {
  var d = document, s = d.createElement('script');
  s.src = 'https://Roidder.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script></div></body></head></html>