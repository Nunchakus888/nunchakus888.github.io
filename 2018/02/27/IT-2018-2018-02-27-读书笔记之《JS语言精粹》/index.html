<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="keywords" content="Javascript,Nunchakus,Tricking,Kufu,Roidder"><meta property="og:image" content="https://nunchakus888.github.io/images/avatar.jpg"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><title>🦋📖</title><meta name="keywords" content="沙聚,JS"><body><div class="container"><div class="nav"><ul><li class="item"><a href="/">🙄️</a></li><li class="item"><a href="/archives">一篇诗</a></li><li class="item"><a href="/category">一壶酒</a></li><li class="item"><a href="/tags/">一曲长歌</a></li><li class="item"><a href="/about/">一剑天涯</a></li></ul></div><article><header><h1 class="title">🦋📖</h1><i class="icon-calendar"></i><span>2018.02.27 | 15:33:00</span></header><div class="content"><hr>
<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><ul>
<li>一个编译单元包含一组可执行的语句。在web浏览器中，每个<script></script>标签提供一个<code>被编译且立即执行的编译单元</code>。因为缺少连接器，javascript把他们一起抛到一个公共全局名字空间中。</li>
<li>return 语句的默认返回值是 undefined</li>
<li><p>结合性（associativity）是操作符在没有圆括号分组的情况下决定其优先级的一种属性。它可能是从左向右结合（lefg-associative）、从右向左结合或无结合。<br>比如加运算符的结合性是从左向右，而一元运算符、赋值运算符及三元条件运算符的结合性是从右向左。</p>
</li>
<li><p>对象字面量产生的对象连接到<code>Object.prototype</code><br>函数对象连接到<code>Function.prototype</code>(该原型对象本身链接到Object.prototype)<br>每个函数在创建时附带两个隐藏属性：函数的<code>上下文和实现函数的行为代码</code>（JS创建一个函数时，会给该对象设置一个“调用“属性。调用函数，可理解为调用次函数的”调用“属性）</p>
</li>
</ul>
<blockquote>
<ul>
<li>每个函数对象在创建时也随机配一个prototype属性。<br>它的值是一个拥有constructor属性且值为该函数的对象（func.prototype.constructor === func）<br>这和隐藏连接到Function.prototype 完全不同</li>
</ul>
</blockquote>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><ul>
<li>当函数调用时，会得到一个“免费”配送的参数，那就是arguments数组。函数可以通过此参数访问所有它被调用时传递给它的参数列表，包括那些没有被分配给函数声明时定义的形式参数的多余参数。</li>
<li>Arguments并不是一个真正的数组。它是一个类数组（array-link）对象。</li>
<li>Arguments拥有一个length属性，但它没有数组的任何方法。</li>
</ul>
<h4 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h4><ul>
<li>通过Object.prototype 添加方法，<code>可以让该方法对所有对象都可用</code>。<br>这样的方式对<code>函数，数组，字符串，数字，布尔值，正则表达式都适用</code><br>eg：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.method = function(name, func) &#123;</span><br><span class="line">  if (!this.prototype[name]) &#123;</span><br><span class="line">    this.prototype[name] = func</span><br><span class="line">  &#125;</span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.method(&apos;trim&apos;, () =&gt; &#123;</span><br><span class="line">  return this.replace(/^\s+$/g, &apos;&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>每个函数对象在创建时也随机配一个prototype属性。</li>
<li>他的值是一个拥有constructor属性且值为该函数的对象（func.prototype.constructor === func）</li>
<li>这和隐藏连接到Function.prototype 完全不同</li>
</ul>
<p>通过函数字面量创建的函数包含一个连接到外部上下文的连接。<br>这被称为闭包。😅</p>
<ul>
<li>This到对象的绑定发生在调用的时候</li>
</ul>
<blockquote>
<h4 id="Js中一共有四种调用模式："><a href="#Js中一共有四种调用模式：" class="headerlink" title="Js中一共有四种调用模式："></a>Js中一共有四种调用模式：</h4><blockquote>
<ul>
<li>1.方法调用：当一个函数被保存为对象的一个属性时，我们称它为一个方法。<br><code>当一个方法被调用时，this被绑定到该对象</code>。<br>方法可以通过this访问自己所属的对象。this到该对象的绑定发生在调用时期。</li>
<li>2.函数调用：当一个函数并非一个对象的属性时，那么它就是被当作一个函数来调用的。<br>此模式调用函数时，this被绑定到全局对象。👀</li>
<li>3.构造器调用：如果在一个函数前面带上new来调用，那么背地里会创建一个连接到该函数prototype成员到新对象。同时，this会被绑定到那个新对象上。<br>一个函数，如果创建时就是希望结合new来调用，那它就被称为构造器函数。</li>
<li>4.apply调用模式：apply方法让我们构建一个参数数组传递给调用函数<br>它允许我们选择this的值。apply方法接受2个参数，第一个是要绑定给this的值，第二个就是一个参数数组。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="recursion"><a href="#recursion" class="headerlink" title="recursion"></a>recursion</h4><p>一些语言提供了tail recursion 尾递归优化（如果一个函数返回自身递归调用的结果，那么调用的过程会被替换为一个循环，可以显著提高速度）<br>javascript没有提供尾递归优化，深度递归的函数可能会因为堆栈溢出而运行失败。</p>
</div></article><div id="disqus_thread"></div><script>var disqus_config = function () {
  this.page.url = "https://nunchakus888.github.io/2018/02/27/IT-2018-2018-02-27-读书笔记之《JS语言精粹》/";
  this.page.identifier = "2018/02/27/IT-2018-2018-02-27-读书笔记之《JS语言精粹》/";
};

(function () {
  var d = document, s = d.createElement('script');
  s.src = 'https://Roidder.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();</script></div></body></head></html>